/*
 * Grafana HTTP API.
 *
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

/// FloatHistogram : A FloatHistogram is needed by PromQL to handle operations that might result in fractional counts. Since the counts in a histogram are unlikely to be too large to be represented precisely by a float64, a FloatHistogram can also be used to represent a histogram with integer counts and thus serves as a more generalized representation.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct FloatHistogram {
    /// Total number of observations. Must be zero or positive.
    #[serde(rename = "Count", skip_serializing_if = "Option::is_none")]
    pub count: Option<f64>,
    /// or alternatively that we are dealing with a gauge histogram, where counter resets do not apply.
    #[serde(rename = "CounterResetHint", skip_serializing_if = "Option::is_none")]
    pub counter_reset_hint: Option<i32>,
    /// Observation counts in buckets. Each represents an absolute count and must be zero or positive.
    #[serde(rename = "PositiveBuckets", skip_serializing_if = "Option::is_none")]
    pub positive_buckets: Option<Vec<f64>>,
    /// Spans for positive and negative buckets (see Span below).
    #[serde(rename = "PositiveSpans", skip_serializing_if = "Option::is_none")]
    pub positive_spans: Option<Vec<models::Span>>,
    /// Currently valid schema numbers are -4 <= n <= 8.  They are all for base-2 bucket schemas, where 1 is a bucket boundary in each case, and then each power of two is divided into 2^n logarithmic buckets.  Or in other words, each bucket boundary is the previous boundary times 2^(2^-n).
    #[serde(rename = "Schema", skip_serializing_if = "Option::is_none")]
    pub schema: Option<i32>,
    /// Sum of observations. This is also used as the stale marker.
    #[serde(rename = "Sum", skip_serializing_if = "Option::is_none")]
    pub sum: Option<f64>,
    /// Observations falling into the zero bucket. Must be zero or positive.
    #[serde(rename = "ZeroCount", skip_serializing_if = "Option::is_none")]
    pub zero_count: Option<f64>,
    /// Width of the zero bucket.
    #[serde(rename = "ZeroThreshold", skip_serializing_if = "Option::is_none")]
    pub zero_threshold: Option<f64>,
}

impl FloatHistogram {
    /// A FloatHistogram is needed by PromQL to handle operations that might result in fractional counts. Since the counts in a histogram are unlikely to be too large to be represented precisely by a float64, a FloatHistogram can also be used to represent a histogram with integer counts and thus serves as a more generalized representation.
    pub fn new() -> FloatHistogram {
        FloatHistogram {
            count: None,
            counter_reset_hint: None,
            positive_buckets: None,
            positive_spans: None,
            schema: None,
            sum: None,
            zero_count: None,
            zero_threshold: None,
        }
    }
}

