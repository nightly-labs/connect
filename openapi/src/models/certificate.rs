/*
 * Grafana HTTP API.
 *
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Certificate {
    #[serde(rename = "AuthorityKeyId", skip_serializing_if = "Option::is_none")]
    pub authority_key_id: Option<Vec<i32>>,
    /// BasicConstraintsValid indicates whether IsCA, MaxPathLen, and MaxPathLenZero are valid.
    #[serde(rename = "BasicConstraintsValid", skip_serializing_if = "Option::is_none")]
    pub basic_constraints_valid: Option<bool>,
    /// CRL Distribution Points
    #[serde(rename = "CRLDistributionPoints", skip_serializing_if = "Option::is_none")]
    pub crl_distribution_points: Option<Vec<String>>,
    /// Subject Alternate Name values. (Note that these values may not be valid if invalid values were contained within a parsed certificate. For example, an element of DNSNames may not be a valid DNS domain name.)
    #[serde(rename = "DNSNames", skip_serializing_if = "Option::is_none")]
    pub dns_names: Option<Vec<String>>,
    #[serde(rename = "EmailAddresses", skip_serializing_if = "Option::is_none")]
    pub email_addresses: Option<Vec<String>>,
    #[serde(rename = "ExcludedDNSDomains", skip_serializing_if = "Option::is_none")]
    pub excluded_dns_domains: Option<Vec<String>>,
    #[serde(rename = "ExcludedEmailAddresses", skip_serializing_if = "Option::is_none")]
    pub excluded_email_addresses: Option<Vec<String>>,
    #[serde(rename = "ExcludedIPRanges", skip_serializing_if = "Option::is_none")]
    pub excluded_ip_ranges: Option<Vec<models::IpNet>>,
    #[serde(rename = "ExcludedURIDomains", skip_serializing_if = "Option::is_none")]
    pub excluded_uri_domains: Option<Vec<String>>,
    #[serde(rename = "ExtKeyUsage", skip_serializing_if = "Option::is_none")]
    pub ext_key_usage: Option<Vec<i64>>,
    /// Extensions contains raw X.509 extensions. When parsing certificates, this can be used to extract non-critical extensions that are not parsed by this package. When marshaling certificates, the Extensions field is ignored, see ExtraExtensions.
    #[serde(rename = "Extensions", skip_serializing_if = "Option::is_none")]
    pub extensions: Option<Vec<models::Extension>>,
    /// ExtraExtensions contains extensions to be copied, raw, into any marshaled certificates. Values override any extensions that would otherwise be produced based on the other fields. The ExtraExtensions field is not populated when parsing certificates, see Extensions.
    #[serde(rename = "ExtraExtensions", skip_serializing_if = "Option::is_none")]
    pub extra_extensions: Option<Vec<models::Extension>>,
    #[serde(rename = "IPAddresses", skip_serializing_if = "Option::is_none")]
    pub ip_addresses: Option<Vec<String>>,
    #[serde(rename = "IsCA", skip_serializing_if = "Option::is_none")]
    pub is_ca: Option<bool>,
    #[serde(rename = "Issuer", skip_serializing_if = "Option::is_none")]
    pub issuer: Option<Box<models::Name>>,
    #[serde(rename = "IssuingCertificateURL", skip_serializing_if = "Option::is_none")]
    pub issuing_certificate_url: Option<Vec<String>>,
    /// KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.
    #[serde(rename = "KeyUsage", skip_serializing_if = "Option::is_none")]
    pub key_usage: Option<i64>,
    /// MaxPathLen and MaxPathLenZero indicate the presence and value of the BasicConstraints' \"pathLenConstraint\".  When parsing a certificate, a positive non-zero MaxPathLen means that the field was specified, -1 means it was unset, and MaxPathLenZero being true mean that the field was explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false should be treated equivalent to -1 (unset).  When generating a certificate, an unset pathLenConstraint can be requested with either MaxPathLen == -1 or using the zero value for both MaxPathLen and MaxPathLenZero.
    #[serde(rename = "MaxPathLen", skip_serializing_if = "Option::is_none")]
    pub max_path_len: Option<i64>,
    /// MaxPathLenZero indicates that BasicConstraintsValid==true and MaxPathLen==0 should be interpreted as an actual maximum path length of zero. Otherwise, that combination is interpreted as MaxPathLen not being set.
    #[serde(rename = "MaxPathLenZero", skip_serializing_if = "Option::is_none")]
    pub max_path_len_zero: Option<bool>,
    #[serde(rename = "NotBefore", skip_serializing_if = "Option::is_none")]
    pub not_before: Option<String>,
    /// RFC 5280, 4.2.2.1 (Authority Information Access)
    #[serde(rename = "OCSPServer", skip_serializing_if = "Option::is_none")]
    pub ocsp_server: Option<Vec<String>>,
    #[serde(rename = "PermittedDNSDomains", skip_serializing_if = "Option::is_none")]
    pub permitted_dns_domains: Option<Vec<String>>,
    /// Name constraints
    #[serde(rename = "PermittedDNSDomainsCritical", skip_serializing_if = "Option::is_none")]
    pub permitted_dns_domains_critical: Option<bool>,
    #[serde(rename = "PermittedEmailAddresses", skip_serializing_if = "Option::is_none")]
    pub permitted_email_addresses: Option<Vec<String>>,
    #[serde(rename = "PermittedIPRanges", skip_serializing_if = "Option::is_none")]
    pub permitted_ip_ranges: Option<Vec<models::IpNet>>,
    #[serde(rename = "PermittedURIDomains", skip_serializing_if = "Option::is_none")]
    pub permitted_uri_domains: Option<Vec<String>>,
    #[serde(rename = "PolicyIdentifiers", skip_serializing_if = "Option::is_none")]
    pub policy_identifiers: Option<Vec<Vec<i64>>>,
    #[serde(rename = "PublicKey", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub public_key: Option<Option<serde_json::Value>>,
    #[serde(rename = "PublicKeyAlgorithm", skip_serializing_if = "Option::is_none")]
    pub public_key_algorithm: Option<i64>,
    #[serde(rename = "Raw", skip_serializing_if = "Option::is_none")]
    pub raw: Option<Vec<i32>>,
    #[serde(rename = "RawIssuer", skip_serializing_if = "Option::is_none")]
    pub raw_issuer: Option<Vec<i32>>,
    #[serde(rename = "RawSubject", skip_serializing_if = "Option::is_none")]
    pub raw_subject: Option<Vec<i32>>,
    #[serde(rename = "RawSubjectPublicKeyInfo", skip_serializing_if = "Option::is_none")]
    pub raw_subject_public_key_info: Option<Vec<i32>>,
    #[serde(rename = "RawTBSCertificate", skip_serializing_if = "Option::is_none")]
    pub raw_tbs_certificate: Option<Vec<i32>>,
    #[serde(rename = "SerialNumber", skip_serializing_if = "Option::is_none")]
    pub serial_number: Option<String>,
    #[serde(rename = "Signature", skip_serializing_if = "Option::is_none")]
    pub signature: Option<Vec<i32>>,
    #[serde(rename = "SignatureAlgorithm", skip_serializing_if = "Option::is_none")]
    pub signature_algorithm: Option<i64>,
    #[serde(rename = "Subject", skip_serializing_if = "Option::is_none")]
    pub subject: Option<Box<models::Name>>,
    #[serde(rename = "SubjectKeyId", skip_serializing_if = "Option::is_none")]
    pub subject_key_id: Option<Vec<i32>>,
    #[serde(rename = "URIs", skip_serializing_if = "Option::is_none")]
    pub uris: Option<Vec<models::Url>>,
    /// UnhandledCriticalExtensions contains a list of extension IDs that were not (fully) processed when parsing. Verify will fail if this slice is non-empty, unless verification is delegated to an OS library which understands all the critical extensions.  Users can access these extensions using Extensions and can remove elements from this slice if they believe that they have been handled.
    #[serde(rename = "UnhandledCriticalExtensions", skip_serializing_if = "Option::is_none")]
    pub unhandled_critical_extensions: Option<Vec<Vec<i64>>>,
    #[serde(rename = "UnknownExtKeyUsage", skip_serializing_if = "Option::is_none")]
    pub unknown_ext_key_usage: Option<Vec<Vec<i64>>>,
    #[serde(rename = "Version", skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

impl Certificate {
    pub fn new() -> Certificate {
        Certificate {
            authority_key_id: None,
            basic_constraints_valid: None,
            crl_distribution_points: None,
            dns_names: None,
            email_addresses: None,
            excluded_dns_domains: None,
            excluded_email_addresses: None,
            excluded_ip_ranges: None,
            excluded_uri_domains: None,
            ext_key_usage: None,
            extensions: None,
            extra_extensions: None,
            ip_addresses: None,
            is_ca: None,
            issuer: None,
            issuing_certificate_url: None,
            key_usage: None,
            max_path_len: None,
            max_path_len_zero: None,
            not_before: None,
            ocsp_server: None,
            permitted_dns_domains: None,
            permitted_dns_domains_critical: None,
            permitted_email_addresses: None,
            permitted_ip_ranges: None,
            permitted_uri_domains: None,
            policy_identifiers: None,
            public_key: None,
            public_key_algorithm: None,
            raw: None,
            raw_issuer: None,
            raw_subject: None,
            raw_subject_public_key_info: None,
            raw_tbs_certificate: None,
            serial_number: None,
            signature: None,
            signature_algorithm: None,
            subject: None,
            subject_key_id: None,
            uris: None,
            unhandled_critical_extensions: None,
            unknown_ext_key_usage: None,
            version: None,
        }
    }
}

