/*
 * Grafana HTTP API.
 *
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct HttpClientConfig {
    #[serde(rename = "authorization", skip_serializing_if = "Option::is_none")]
    pub authorization: Option<Box<models::Authorization>>,
    #[serde(rename = "basic_auth", skip_serializing_if = "Option::is_none")]
    pub basic_auth: Option<Box<models::BasicAuth>>,
    #[serde(rename = "bearer_token", skip_serializing_if = "Option::is_none")]
    pub bearer_token: Option<String>,
    /// The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.
    #[serde(rename = "bearer_token_file", skip_serializing_if = "Option::is_none")]
    pub bearer_token_file: Option<String>,
    /// EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.
    #[serde(rename = "enable_http2", skip_serializing_if = "Option::is_none")]
    pub enable_http2: Option<bool>,
    /// FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.
    #[serde(rename = "follow_redirects", skip_serializing_if = "Option::is_none")]
    pub follow_redirects: Option<bool>,
    /// NoProxy contains addresses that should not use a proxy.
    #[serde(rename = "no_proxy", skip_serializing_if = "Option::is_none")]
    pub no_proxy: Option<String>,
    #[serde(rename = "oauth2", skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<Box<models::OAuth2>>,
    #[serde(rename = "proxy_connect_header", skip_serializing_if = "Option::is_none")]
    pub proxy_connect_header: Option<std::collections::HashMap<String, Vec<String>>>,
    /// ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.
    #[serde(rename = "proxy_from_environment", skip_serializing_if = "Option::is_none")]
    pub proxy_from_environment: Option<bool>,
    #[serde(rename = "proxy_url", skip_serializing_if = "Option::is_none")]
    pub proxy_url: Option<Box<models::Url>>,
    #[serde(rename = "tls_config", skip_serializing_if = "Option::is_none")]
    pub tls_config: Option<Box<models::TlsConfig>>,
}

impl HttpClientConfig {
    pub fn new() -> HttpClientConfig {
        HttpClientConfig {
            authorization: None,
            basic_auth: None,
            bearer_token: None,
            bearer_token_file: None,
            enable_http2: None,
            follow_redirects: None,
            no_proxy: None,
            oauth2: None,
            proxy_connect_header: None,
            proxy_from_environment: None,
            proxy_url: None,
            tls_config: None,
        }
    }
}

